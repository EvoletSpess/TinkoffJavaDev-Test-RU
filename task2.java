import java.util.*;

public class Solution {
    public static void main(String[] args) {
        // Справляемся с вводом:
        Scanner input = new Scanner(System.in);
        String text = input.nextLine();
        int[] counts = new int[26]; // В английском алфавите максимум 26 букв, поэтому можно сделать статичное целочисленное множество

        /* 
        * Смысл данного цикла - повысить на 1 
        * Можно представить массив counts как стэк бумажек, в котором у каждой буквы англ алфавита свой стэк с 0.
        * Когда цикл достаёт какой-то символ, он находит его статичный индекс с помощью вычисления ниже: [character - 'a']
        * И увеличивает его счёт на один, как бы увеличивая стэк бумажек.
        * В итоге получается, что поступившая строка разделяется на символы и частота этих символов заносится в целочисленный массив
        */
        for (char character : text.toCharArray()) {
            counts[character - 'a']++;
        }

        // Вызов метода getMinCount, передача ему массива с подсчитанной частотой букв и назначение ответа к переменной minCount
        int minCount = getMinCount(counts);

        // Вывод максимально возможного кол-ва слов "sheriff" из введенной строки
        System.out.println(minCount);
    }

    private static int getMinCount(int[] counts) {
        /*
         * Минимальное количество посчитанных с помощью цикла букв.
         * Так как нам лень/мы не знаем индекса именно буквы 's', например, мы просто минусуем юникодовское значение
         * и получаем тем самым индекс нужной нам буквы. Достаём оттуда посчитанную частоту встречи и с помощью
         * библиотеки Math и метода min выбираем наименьшее из этих числе и храним в начальном значении minCount
         * далее это значение подвергается агрегации, уменьшаясь, если частота нужных букв становится, ну, меньше
         */
        
        int minCount = Math.min(counts['s' - 'a'], counts['h' - 'a']);
        minCount = Math.min(minCount, counts['e' - 'a']);
        minCount = Math.min(minCount, counts['r' - 'a']);
        minCount = Math.min(minCount, counts['i' - 'a']);
        minCount = Math.min(minCount, counts['f' - 'a'] / 2); // так как 'f' встречается в слове "sheriff" дважды
        return minCount;
    }
}
